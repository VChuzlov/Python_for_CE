---
marp: true
theme: base
size: 16:9
fontsize: 12px;
style: |
  section::after {
    content: 'Слайд ' attr(data-marpit-pagination) ' / ' attr(data-marpit-pagination-total);
  }

  h1 {
    color: 	rgb(40, 190, 70);
  }
  
  h5 {
    color: 	rgb(101, 115, 255);
  }

  .columns {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 1rem;
  }
  
  .columns3 {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 1rem;
  }

  .small-text {
    font-size: 1.45rem;
  }
  .headerless {
        display: none;
    }

math: mathjax
---

<!-- СМYК (75,0,100,0), RGB (40,190,70)

СМYК (0,0,0,100), RGB (0,0,0) -->

<!-- СМYК (0,33,93,0), RGB (255,182,0)

 СМYК (0,84,45,0), RGB (255,68,96)

 СМYК (72,59,0,0), RGB (101,115,255) -->

<style>
section {
  font-family: 'Roboto', 'Segoe UI', 'Liberation Sans', 'Helvetica', 'Arial', sans-serif !important;
  font-size: 1.55rem;
  padding: 3.5rem;
  justify-content: start;
}
</style>

![bg left](sectiongk.jpeg)

![w:520](logoclr.png)

<br>
<br>

# Python для задач химической технологии



## Лекция №3 - Введение в бибилиотеку NumPy
<br>
<br>
Вячеслав Алексеевич Чузлов

к.т.н., доцент ОХИ ИШПР ТПУ 

---

<!-- paginate: true -->

# Введение

<div class="columns">

<div>

- Библиотека NumPy (**Num**erical **Py**thon – «числовой Python») предоставляет набор эффективных инструментов для хранения и работы с данными.
- Массивы библиотеки NumPy отдаленно напоминают списки Python, однако обеспечивают намного более эффективное хранение и выполнение операций с данными при росте размера массивов.
- Массивы библиотеки NumPy формируют ядро практически всей экосистемы утилит для работы с большими данными (BigData) в Python.

</div>

<div>

![w:300px](NumPy_logo.png)

> По установившейся традиции, большинство пользователей импортируют пакет NumPy, используя сокращение `np`:

```py
>>> import numpy as np
```

</div>

</div>

---

<style scoped>
  section {
    justify-content: center;
    font-size: 30px
  }
</style>

![bg](contentinteriorw.jpeg)

# Создание массивов NumPy

<!-- _paginate: skip -->


---

# Создание массивов NumPy

- Для того, чтобы создать объект массива NumPy из объекта списка Python, можно использовать функцию `np.array`:

```pycon
>>> import numpy as np
>>> np.array([1, 3, 5, 4, 2]) # Массив целочисленных значений
array([1, 3, 5, 4, 2])
```

- В отличие от стандартных списков Python, массивы NumPy могут содержать элементы только одного типа. Если типы элементов не совпадают, NumPy сделает попытку повышающего приведения типов:

```pycon
>>> np.array([3.14, 4, 2, 3, 2.71])
array([3.14, 4. , 2. , 3. , 2.71])
```

---

# Создание массивов NumPy

- В тех случаях, когда требуется явно задать тип результирующего массива, необходимо воспользоваться ключевым аргументом `dtype`:

```pycon
>>> np.array([1, 3, 5, 4, 2], dtype='float32')
array([1., 3., 5., 4., 2.], dtype=float32)
```

<br>

- В отличие от списков, массивы NumPy можно явным образом описать как многомерные:

```pycon
>>> np.array([range(i, i + 3) for i in [2, 4, 6]])
array([[2, 3, 4],
       [4, 5, 6],
       [6, 7, 8]])
```

---

# Создание массивов NumPy

> Массивы больших размеров эффективнее генерировать с помощью встроенных методов.

- Создаем массив целых чисел длины $10$, заполненный <mark>нулями</mark>:

```pycon
>>> import numpy as np
>>> np.zeros(10, dtype=int)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
```
<br>

- Создадим массив размером $3 \times 5$ значений с плавающей точкой, заполненный <mark>единицами</mark>:

```pycon
>>> np.ones((3, 5), dtype=float)
array([[1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.]])
```

---

# Создание массивов NumPy

- Создадим массив размером $3 \times 5$, заполненный значением $2.98$:

```pycon
>>> np.full((3, 5), 2.98)
array([[2.98, 2.98, 2.98, 2.98, 2.98],
       [2.98, 2.98, 2.98, 2.98, 2.98],
       [2.98, 2.98, 2.98, 2.98, 2.98]])
```

- Создадим массив, заполненный линейной последовательностью, начинающейся с $0$ и заканчивающейся $20$ (<mark>не включая</mark>), с шагом $2$ (аналогично встроенной функции `range()`):

```pycon
>>> np.arange(0, 20, 2)
array([ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18])
```

- Создадим массив из <mark>пяти</mark> значений, *равномерно* располагающихся между $0$ и $1$:

```pycon
>>> np.linspace(0, 1, 5)
array([0. , 0.25, 0.5 , 0.75, 1. ])
```

---

# Создание массивов NumPy

- Создадим массив размером $3 \times 3$ равномерно распределенных случайных значений от $0$ до $1$ (<mark>не включая</mark>):

```pycon
>>> np.random.random((3, 3))
array([[0.28303209, 0.54071726, 0.93183376],
       [0.02403954, 0.92295936, 0.62619599],
       [0.06875703, 0.61762719, 0.47795471]])
```

<br>

- Создадим массив размером $3 \times 3$ случайных целых чисел в интервале $[0; 10)$

```pycon
>>> np.random.randint(0, 10, (3, 3))
array([[3, 6, 7],
       [5, 7, 4],
       [9, 3, 5]])
```

---

# Инициализация массива из функции

- Для создания массива, инициализируемого значениями, которые вычисляются
с помощью некоторой функции, используется метод `np.fromfunction()`,
принимающий в качестве аргументов эту функцию и кортеж, определяющий
форму требуемого массива. 
- Сама функция должна принимать количество аргументов, совпадающее с размерностями создаваемого массива: эти аргументы индексируют каждый элемент, в который функция возвращает значение.

```pycon
>>> import numpy as np
>>> def f(i: int, j: int) -> int:
...     return 2 * j * i
>>> np.fromfunction(f,(4,3))
array([[ 0.,  0.,  0.],
       [ 0.,  2.,  4.],
       [ 0.,  4.,  8.],
       [ 0.,  6., 12.]])
```

---

<style scoped>
  section {
    justify-content: center;
    font-size: 30px
  }
</style>

![bg](contentinteriorw.jpeg)

# Аттрибуты массивов NumPy для интроспекции

<!-- _paginate: skip -->

---

# Аттрибуты массивов NumPy для интроспекции

> Массив NumPy знает свой ранг, форму, размер, тип `dtype` и другие свойства: их можно определить прямо из специальных атрибутов:

```pycon
>>> import numpy as np
>>> a = np.array(((1, 0, 1), (0, 1, 0)))
>>> a.shape  # 2 строки, 3 столбца
(2, 3)
>>> a.ndim  # Ранг (число измерений)
2
>>> a.size  # Общее количество элементов
6
>>> a.dtype
dtype('int64')
>>> a.data
<memory at 0x102387308>
```

---

# Аттрибуты массивов NumPy для интроспекции

|Атрибут|Описание|
|-|-|
|`shape`|Измерения массива: размер массива вдоль каждой из его осей, возвращается как кортеж целых чисел|
|`ndim`|Количество осей (измерений). Обратите внимание: `ndim == len(shape)`|
|`size`|Общее количество элементов в массиве, равное произведению элементов кортежа `shape`|
|`dtype`|Тип данных массива|
|`data`|«Буфер» в памяти, содержащий действительные элементы массива|
|`itemsize`|Размер в байтах каждого элемента|

---

<style scoped>
  section {
    justify-content: center;
    font-size: 30px
  }
</style>

![bg](contentinteriorw.jpeg)

# Стандартные типы данных NumPy

<!-- _paginate: skip -->

---

# Стандартные типы данных NumPy

|<div style="width:200px">Тип данных</div>|Описание|
|-|-|
|`int16`|Целое число (от $–32 \space 768$ до $32 \space 767$)|
|`int32`|Целое число (от $–2 \space 147 \space 483 \space 648$ до $2 \space 147 \space 483 \space 647$)|
|`int64`|Целое число (от $–9 \space 223 \space 372 \space 036 \space 854 \space 775 \space 808$ до $9 \space 223 \space 372 \space 036 \space 854 \space 775 \space 807$)|
|`uint16`|Беззнаковое целое число (от $0$ до $65 \space 535$)|
|`uint32`|Беззнаковое целое число (от $0$ до $4 \space 294 \space 967 \space 295$)|
|`uint64`|Беззнаковое целое число (от $0$ до $18 \space 446 \space 744 \space 073 \space 709 \space 551 \space 615$)|
|`float16`|Число с плавающей точкой с половинной точностью: $1$ бит знак, $5$ бит порядок, $10$ бит мантисса|


---

# Стандартные типы данных NumPy

|<div style="width:200px">Тип данных</div>|Описание|
|-|-|
|`float32`|Число с плавающей точкой с одинарной точностью: $1$ бит знак, $8$ бит порядок, $23$ бита мантисса|
|`float64`|Число с плавающей точкой с удвоенной точностью: $1$ бит знак, $11$ бит порядок, $52$ бита мантисса|
|`complex64`|Комплексное число, представленное двумя $32$-битными числами|
|`complex128`|Комплексное число, представленное двумя $64$-битными числами|

<div class="columns">

<div>

При создании массива тип данных можно указывать с помощью строк:
```pycon
np.zeros(10, dtype='int16')
``` 

</div>

<div>

или соответствующих объектов библиотеки NumPy:
```pycon
np.zeros(10, dtype=np.int16)
```

</div>

</div>

---

<style scoped>
  section {
    justify-content: center;
    font-size: 30px
  }
</style>

![bg](contentinteriorw.jpeg)

# Доступ к элементам массива NumPy

<!-- _paginate: skip -->

---

# Индексация элементов массива NumPy

- В одномерном массиве обратиться к $i$-му (считая с $0$) значению можно по требуемому индексу в квадратных скобках, по аналогии со стандартными списками:

```pycon
>>> import numpy as np
>>> x1 = np.array([5, 0, 3, 3, 7, 9])
>>> x1[0]
5
>>> x1[4]
7
>>> x1[‐1]
9
>>> x1[‐2]
7
```

---

# Индексация элементов массива NumPy

- Для обращения к элементам матрицы нужно указать кортеж индексов,  разделенных запятыми:

```pycon
>>> x2 = np.array([[3, 5, 2, 4], [7, 6, 8, 8], [1, 6, 7, 7]])
>>> x2
array([[3, 5, 2, 4],
       [7, 6, 8, 8],
       [1, 6, 7, 7]])
>>> x2[0, 0]
3
>>> x2[2, 0]
1
>>> x2[2, ‐1]
7
```

---

# Индексация элементов массива NumPy

- При помощи любой из указанных выше нотаций можно изменять значения элементов массива:

```pycon
>>> x2[0, 0] = 24
>>> x2
array([[24, 5, 2, 4],
       [ 7, 6, 8, 8],
       [ 1, 6, 7, 7]])
```

> Следует помнить, что, в отличие от списков, массивы NumPy имеют фиксированный тип данных. Если вставить в массив <mark>*целых*</mark> чисел значение с <mark>*плавающей точкой*</mark>, оно будет <span style="color:red">**неявно усечено**</span>:

```pycon
>>> x1[0] = 2.71828  # Это значение будет усечено!
>>> x1
array([2, 0, 3, 3, 7, 9])
```

---

# Срезы массивов: доступ к подмассивам

- Синтаксически срезы массивов NumPy соответствуют срезам стандартных списков Python: `x[начало:конец:шаг]` <br> при этом любое из значений можно не указывать, тогда по умолчанию будут приняты следующие значения: `начало = 0`, `конец = размер соответствующего измерения`, `шаг = 1`.

#### Одномерные подмассивы

```pycon
>>> x = np.arange(10)
>>> x
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> x[:5]
array([0, 1, 2, 3, 4])
>>> x[4:7]
array([4, 5, 6])
```

---

# Срезы массивов: доступ к подмассивам

```pycon
>>> x[::2]  # каждый второй элемент
array([0, 2, 4, 6, 8])
>>> x[1::2]  # каждый второй элемент, начиная с индекса 1
array([1, 3, 5, 7, 9])
```

<br>

- Также сохранена возможность использования отрицательного значения параметра шаг. Тогда значения по умолчанию для параметров **начало** и **конец** будут поменяны местами. Это быстрый способ перевернуть массив:

```pycon
>>> x[::‐1]  # все элементы в обратном порядке
array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
>>> x[5::‐1]  # все элементы в обратном порядке, начиная с индекса 5
array([5, 4, 3, 2, 1, 0])
```

---

# Срезы массивов: доступ к подмассивам

#### Многомерные подмассивы

```pycon
>>> x = np.random.randint(1, 10, (3, 4))
>>> x
array([[3, 3, 4, 9],
       [8, 6, 5, 5],
       [1, 8, 9, 6]])
>>> x[:2, :3]  # две строки, три столбца
array([[3, 3, 4],
       [8, 6, 5]])
>>> x[:3, ::2]  # все строки, каждый второй столбец
array([[3, 4],
       [8, 5],
       [1, 9]])
>>> x[::‐1, ::‐1]  # обратный порядок строк и столбцов
array([[6, 9, 8, 1],
       [5, 5, 6, 8],
       [9, 4, 3, 3]])
```

---

# Срезы массивов: доступ к подмассивам

##### Доступ к строкам и столбцам массива

- Распространенной задачей является доступ к отдельным строкам или столбцам массива. Получить такой доступ можно при помощи комбинации операций индексации и среза:

```pycon
>>> x = np.random.random((3, 4))
>>> x
array([[0.48355024, 0.782125 , 0.59495727, 0.00922272],
       [0.85367868, 0.68002585, 0.44782773, 0.59118661],
       [0.23442892, 0.9418546 , 0.89586513, 0.92833265]])
>>> x[:, 0]  # первый столбец массива
array([0.48355024, 0.85367868, 0.23442892])
>>> x[0]  # первая строка массива
array([0.48355024, 0.782125 , 0.59495727, 0.00922272])
```

---

# Срезы массивов создают разделяемые ссылки

- Срезы массивов возвращают <span style="color:rgb(255,182,0)">**разделяемые ссылки**</span> (синонимы), а не <mark>**копии**</mark> данных массива.
- Этим срезы массивов библиотеки NumPy отличаются от срезов списков языка Python (срезы списков создают новые объекты):

```pycon
>>> x = np.random.randint(1, 10, (3, 4))
>>> x
array([[2, 6, 5, 3],
       [3, 4, 4, 4],
       [8, 2, 9, 9]])
```
Получим из него матрицу $2 \times 2$:

```pycon
>>> x2_sub = x[:2, :2]
>>> x2_sub
array([[2, 6],
       [3, 4]])
```

---

# Срезы массивов создают разделяемые ссылки

Теперь, если изменить значения этой матрицы, исходный массив также изменится:

```pycon
>>> x2_sub[0, 0] = 100
>>> x2_sub
array([[100, 6],
       [  3, 4]])
>>> x
array([[100, 6, 5, 3],
       [  3, 4, 4, 4],
       [  8, 2, 9, 9]])
```

---

# Создание копий массивов

> Для создания копии массива существует метод `copy()`:

```pycon
>>> x2_subcopy = x[:2, :2].copy()
>>> x2_subcopy
array([[100, 6],
       [  3, 4]])
```
Теперь, если изменить значения этого подмассива, то исходный массив не изменится:

```pycon
>>> x2_subcopy[0, 0] = 2
>>> x2_subcopy
array([[2, 6],
       [3, 4]])
>>> x
array([[100, 6, 5, 3],
       [ 3, 4, 4, 4],
       [ 8, 2, 9, 9]])
```

---

<style scoped>
  section {
    justify-content: center;
    font-size: 30px
  }
</style>

![bg](contentinteriorw.jpeg)

# Изменение формы массива

<!-- _paginate: skip -->

---

# Методы `flatten()` и `ravel()`

Предположим, что необходимо «выпрямить» многомерный массив вдоль одной оси. Библиотека NumPy предоставляет для этого два метода: `flatten()` и `ravel()`.

- Оба метода создают одномерный массив в соответствии с его внутренним
порядком элементов (по строкам).
- Метод `flatten()` возвращает независимую копию элементов и в общем случае медленнее, чем метод `ravel()`.
- Метод `ravel()` пытается вернуть **представление** преобразованного в одно измерение массива. 

> <span style="color:rgb(255,182,0)">**Представление массива**</span> – это массив NumPy, который в данном случае имеет форму, отличающуюся от формы исходного массива, но не содержит «собственных» элементов данных: он содержит **ссылки** на элементы другого массива.

---

# Методы `flatten()` и `ravel()`

```pycon
>>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> b = a.flatten()  # Создает независимую, одномерную копию массива a
>>> b
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> b[3] = 0
>>> b
array([1, 2, 3, 0, 5, 6, 7, 8, 9])
>>> a  # Массив a не изменяется
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
```

> Присваивание массиву `b` не изменяет массив `a`, потому что это абсолютно независимые объекты, которые не используют данные совместно.

---

# Методы `flatten()` и `ravel()`

```pycon
>>> c = a.ravel()
>>> c
array([1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> c[3] = 0
>>> c
array([1, 2, 3, 0, 5, 6, 7, 8, 9])
>>> a
array([[1, 2, 3],
       [0, 5, 6],
       [7, 8, 9]])
```

> Необходимо всегда помнить о том, что хотя метод `ravel()` «работает наилучшим образом», возвращая представление внутренних данных, разнообразные операции с массивами (включая вырезание группы элементов (slicing)) могут оставлять элементы хранящимися в несмежных локациях памяти. 
> В этом случае у метода `ravel()` нет другого выбора, кроме создания копии массива.

---

# Метод `resize()`

- Размер массива может быть изменен (для самого исходного массива) с помощью метода `resize,()` который в качестве аргументов принимает новые значения измерений.

<br>

```pycon
>>> a = np.linspace(1, 4, 4)
>>> print(a)
[1. 2. 3. 4.]
>>> a.resize(2, 2)  # Изменяет форму исходного массива, возвращаемого значения нет
>>> print(a)
[[ 1. 2.]
 [ 3. 4.]]
```

---

# Метод `reshape()`

- Метод `reshape()` возвращает <mark>представление</mark> исходного массива с изменением его формы. Исходный массив не изменяется, но оба объекта совместно используют внутренние данные.

<br>

```pycon
>>>  a = np.linspace(1, 4, 4)
>>> b = a.reshape(2, 2)
>>> print(a)
[1. 2. 3. 4.]
>>> print(b)
[[ 1. 2.]
 [ 3. 4.]]
>>>  b[0, 0] = -99
>>> print(b)
[[-99. 2.]
 [  3. 4.]]
>>>  print(a)
[-99. 2. 3. 4.]
```

---

# Транспонирование массива

- Метод `transpose()` возвращает представление массива с транспонированными осями. Для двумерного массива это обычная операция транспонирования матрицы:

```pycon
>>> a = np.linspace(1, 6, 6).reshape(3, 2)
>>> a
array([[ 1., 2.],
       [ 3., 4.],
       [ 5., 6.]])
>>> a.transpose()  # Или просто a.T
array([[ 1., 3., 5.],
       [ 2., 4., 6.]])
```

- Транспонирование одномерного массива возвращает этот же неизмененный массив:

```pycon
>>> b = np.array([100, 101, 102, 103])
>>> b.T
array([100, 101, 102, 103])
```

---

# Объединение и разделение массивов

- Функции `np.vstack()`, `np.hstack()` и `np.dstack()` объединяют массивы по вертикали (по строкам), по горизонтали (по столбцам) и по всем измерениям (вдоль третьей оси).

```pycon
>>> a = np.array([0, 0, 0, 0])
>>> b = np.array([1, 1, 1, 1])
>>> c = np.array([2, 2, 2, 2])
>>> np.vstack((a, b, c))
array([[0, 0, 0, 0],
       [1, 1, 1, 1],
       [2, 2, 2, 2]])
>>> np.hstack((a, b, c))
array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2])
>>> np.dstack((a, b, c))
array([[[0, 1, 2],
        [0, 1, 2],
        [0, 1, 2],
        [0, 1, 2]]])
```

> *Обратите внимание*: созданный массив содержит <mark>независимую копию</mark> данных из исходных массивов

---

# Объединение и разделение массивов

- Противоположные операции `np.vsplit()`, `np.hsplit()` и `np.dsplit()` разделяют один массив на несколько массивов по строкам, столбцам или «в глубину».

- В дополнение к ссылке на разделяемый массив эти методы требуют аргумента, определяющего, как должен разделяться массив. Если этот аргумент представлен одним целым числом, то массив разделяется на указанное количество массивов равного размера вдоль соответствующей оси.

```pycon
>>> a = np.arange(6)
>>> a
array([ 0, 1, 2, 3, 4, 5])
>>> np.hsplit(a, 3)
[array([ 0, 1]), array([ 2, 3]), array([ 4, 5])]
```

- Здесь можно видеть, что возвращается <mark>*список*</mark> объектов массивов.

---

<style scoped>
  section {
    justify-content: center;
    font-size: 30px
  }
</style>

<!-- _paginate: skip -->
![bg right opacity:.3](sectiongk.jpeg)

![w:520](logoclr.png)

<br>
<br>

# Благодарю за внимание!

<br>
<br>

Вячеслав Алексеевич Чузлов
к.т.н., доцент ОХИ ИШПР
