---
marp: true
theme: base
size: 16:9
fontsize: 12px;
style: |
  section::after {
    content: 'Слайд ' attr(data-marpit-pagination) ' / ' attr(data-marpit-pagination-total);
  }


  h1 {
    color: 	rgb(40, 190, 70);
  }
  
  .columns {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 1rem;
  }
  
  .columns3 {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 1rem;
  }

  .small-text {
    font-size: 1.45rem;
  }
  .headerless {
        display: none;
    }

---

<style>
section {
  font-family: 'Roboto', 'Segoe UI', 'Liberation Sans', 'Helvetica', 'Arial', sans-serif !important;
  font-size: 1.55rem;
  padding: 3.5rem;
  justify-content: start;
}
</style>

![bg left](sectiongk.jpeg)

![w:520](logoclr.png)

<br>
<br>

# Python для задач химической технологии



## Лекция №2 - Функции
<br>
<br>
Вячеслав Алексеевич Чузлов

к.т.н., доцент ОХИ ИШПР ТПУ 

---

<style scoped>
  section {
    justify-content: center;
    font-size: 30px
  }
</style>

![bg](contentinteriorw.jpeg)

# Описание функций

<!-- _paginate: skip -->


---


<!-- paginate: true -->


# Написание кода функций

- <span style="color: #ffb600;">**Функции**</span> – это многократно используемые фрагменты программы. Они позволяют дать имя определенному блоку команд с тем, чтобы в последствии запускать блок по указанному имени в любом месте программы и сколь угодно много раз. Это называется **вызовом функции**.
- Функции определяются при помощи зарезервированного слова `def`. После этого слова указывается имя функции, за которым следует пара скобок, в которых можно указать имена некоторых переменных, и заключительное двоеточие в конце строки. Далее следует блок команд (инструкций), составляющих тело функции.
- <span style="color: #ffb600;">**Сигнатура функции**</span> – часть общего объявления функции, позволяющая средствами трансляции идентифицировать функцию среди других. Составляющие сигнатуры:

<div class="columns">
<div>

1. имя функции;
2. аргументы функции;
3. возвращаемые значения.

</div>

<div>

```py
def say_hi():
    print('Hi!)


say_hi()  # Hi!
```

</div>

</div>


---

# Оператор `def`

- Оператор `def` создает объект функции и присваивает его имени.
- Общий формат оператора `def` выглядит следующим образом:

```py
def function_name(arg1, arg2, ..., argN):
    operator1  # операторы могут отсутствовать
    operator2
    ...
    operatorN
    return  # может быть пропущен
```

- В строке заголовка `def` указывается имя функции, которому присваивается объект функции, а также список из нуля и более аргументов (иногда называемых параметрами) в круглых скобках.
- Именам аргументов в заголовке присваиваются объекты, передаваемые в круглых скобках
при вызове функции.

---

# Оператор `return`

- Тело функции почти всегда содержит оператор `return`:

```py
def function_name(arg1, arg2, ..., arg3):
    operators
    ...
    return ...
```

- Оператор `return` в Python может появляться где угодно в теле функции; по достижении он заканчивает выполнение функции и возвращает результат обратно вызывающему коду.
- Оператор `return` состоит из необязательного выражения с объектным значением, которое дает результат функции. Если значение опущено, тогда `return` возвращает `None`.
- Оператор `return` сам по себе также необязателен; если он отсутствует, то выход из функции происходит, когда интерпретатор достигает конца тела функции. Формально функция без оператора `return` автоматически возвращает объект `None`.
- Хорошим тоном является явное использование пустого оператора `return` для дополнительного пояснения того, что функция ничего не возвращает.

---

# Оператор `return`

- Оператор `return` используется для возврата из функции, т.е. для прекращения её работы и выхода из неё. При этом можно также вернуть некоторое значение из функции.
- Оператор `return` в Python может появляться где угодно в теле функции; по достижении он заканчивает выполнение функции и возвращает результат обратно вызывающему коду.

<div class="columns">

<div>

```py
def maximum(x: float, y: float) -> float | str:
    if x > y:
        return x
    
    elif x == y:
        return 'Equals'
    
    else:
        return y


print(maximum(20, 30))  # 30
```

</div>

<div>

```py
def maximum(x: float, y: float) -> float | str:
    if x > y:
        return x
    
    if x == y:
        return 'Equals'
    
    return y



print(maximum(20, 30))  # 30
```

</div>

</div>

---

# Параметры функций

- Функции могут принимать параметры, т.е. некоторые значения, передаваемые функции для того, чтобы она что-либо сделала с ними.
- Параметры указываются в скобках при объявлении функции и разделяются запятыми. Аналогично мы передаём значения, когда вызываем функцию.
- Обратите внимание на терминологию: имена, указанные в объявлении функции, называются <span style="color: #ffb600;">**параметрами**</span>, тогда как значения, которые будут переданы функции при её вызове – <span style="color: #ffb600;">**аргументами**</span>.

---

# Примеры определения и вызова функций

Ниже показано <span style="color: #ffb600;">**определение**</span> функции по имени `times`, которая возвращает произведение двух аргументов:

```py
def times(x, y):
    return x * y
```

- Когда интерпретатор встречает и выполняет этот оператор `def`, он создает новый объект функции, умещающий в себе код функции, и присваивает его имени `times`.
- Обычно такой оператор находится в файле модуля и выполняется при его импортировании.

---

# Примеры определения и вызова функций

- Оператор `def` создает функцию, но не вызывает ее.
- После выполнения `def` функцию можно <span style="color: #ffb600;">**вызывать**</span> (выполнить) в своей программе, добавляя к имени функции круглые скобки.
- Круглые скобки могут дополнительно содержать один и более объектов-аргументов, подлежащих передаче (присваиванию) именам в заголовке функции.
  
```py
print(times(3, 5))  # 15
print(times('abc', 2))  # abcabc
```

- Выражение вызова передает в `times` два аргумента. Аргументы передаются по порядку следования.
- Возвращаемый объект можно присвоить переменной:

```py
x = times(3.14, 3)
print(x)  # 9.42
```

---

# Примеры определения и вызова функций

```py
def print_max(a, b):
    if a == b:
        print(f'{a} equals to {b}')
    else:
        m = a if a > b else b
        print(f'{m} is max)


print_max(6, 7)  # 7 is max
print_max(3, 3)  # 3 equals to 3

x, y = 5, 2
print_max(x, y)  # 5 is max
```

---

<style scoped>
  section {
    justify-content: center;
    font-size: 30px
  }
</style>

![bg](contentinteriorw.jpeg)

# Области видимости

<!-- _paginate: skip -->


---

# Локальные переменные

- При объявлении переменных внутри определения функции, они никоим образом не связаны с другими переменными с таким же именем за пределами функции – т.е. имена переменных являются локальными в функции.
- Это называется <span style="color: #ffb600;">**областью видимости переменной**</span>. Область видимости всех переменных ограничена блоком, в котором они объявлены, начиная с точки объявления имени.

```py
x = 50


def func(x):
    print(f'x = {x}')  # x = 50
    x = 2
    print(f'Replace x to {x}')  # Replace x to 2


func(x)
print(f'x = {x}')  # x = 50
```

---

# Области видимости и вложенные функции

Рассмотрим пример вложенной области видимости:

```py
x = 24  # Имя в глобальной области видимости

def func1():
    x = 55  # Локальное имя объемлющего def

    def func2():
        print(x)  # Ссылка во вложенном def
    
    func2()

func1()  # Выводит 55: локальное имя объемлющего def
```

- Здесь вложенный оператор `def` запускается, пока выполняется функция `func1()`; он создает объект функции и присваивает его имени `func2()`, т.е. локальной переменной внутри локальной области видимости `func1()`.
- `func2()` представляет собой временную функцию, которая существует только в период выполнения (и видима только в коде) объемлющей функции `func1()`.

---

# Области видимости и вложенные функции

- Поиск в объемлющей области видимости работает, даже если уже произошел возврат из объемлющей функции.

```py
def func1():
    x = 44

    def func2():
        print(x)  # Помнит значение x из области видимости объемлющего def
    
    return func2  # Возвращает объект функции func2, но не вызывает ее

action = func1()  # Создает и возвращает объект функции
action()  # Вызов функции: выводит 44
```

- Функции в Python могут передаваться как возвращаемые значения.
- Вызов `action()` вызывает функцию `func2()`, созданную во время выполнения `func1()`.
- Функция `func2()` помнит значение `x` из объемлющей области видимости функции `func1()`, хотя `func1()` больше неактивна.


---

# Замыкания

- <span style="color: #ffb600;">**Замыкание**</span> – это методика **функционального программирования**, идея которой заключается в запоминании значений из объемлющих областей видимости, невзирая на то, присутствуют ли еще эти области видимости в памяти.

```py
def maker(n):
    
    def action(x):
        return x ** n  # action сохраняет значение n
    
    return action
```

- Функция `maker()` создает `action()`, и возвращает `action()` без выполнения.
- Если вызвать внешнюю функцию – будет получена ссылка на вложенную функцию:
```py
f = maker(3)
print(f)  # <function maker.<locals>.action at 0x000001987C301160>
```

---

# Замыкания

- Вызов результата, возвращенного внешней функцией приводит к запуску вложенной функции, названной `action()` внутри `maker()`:
```py
# Передача 5 аргументу x, в n запоминается 3: 5 ** 3
print(f(5))  # 125
# 2 ** 3
print(f(2))  # 8
```
- Если снова вызвать внешнюю функцию, то получим новую вложенную функцию с другой информацией о состоянии. Каждый вызов замыкания получает собственный набор информации о состоянии. Функция `g` запоминает $2$, a `f` запоминает $3$:
```py
g = maker(2)
print(g(5))  # 25
print(f(5))  # 125
```

---

# Аннотация типов (type hints)

<span style="color: #ffb600;">**Аннотоация типов**</span> - это подсказки типов данных в Python, которые помогают разработчикам лучше понимать и контролировать типы данных, используемые в коде. 

> Вместо того, чтобы полагаться на динамическую типизацию, где типы данных определяются автоматически во время выполнения, Вы можете явно указать типы данных переменных, функций и классов, используя _type hints_.

#### Перимущества использования аннотации типов

- Улучшение читаемости кода: Явное указание типов данных делает код более понятным для других разработчиков.
- Помощь в обнаружении ошибок: _Type hints_ позволяют инструментам статического анализа кода (например, mypy, Pyright) проверять код на наличие ошибок типов данных.
- Улучшение автодополнения кода: Интегрированные среды разработки могут использовать *type hints* для предоставления более точных предложений автодополнения кода.

---

# Аннотация типов (type hints)

- Для указания типа переменной используйте двоеточие и тип данных:
```py
name: str = 'John'
age: int = 25
```
- Для указания типов аргументов функции и возвращаемого значения используйте `->`:
```py
def greet(name: str) -> str:
    return 'Hello, ' + name
```
- Для указания типов атрибутов класса используйте аннотации типов и метод `__init__()`:
```py
class Person:
    def __init__(self, name: str, age: int) -> None:
        self.name: str = name
        self.age: int = age
        return
```

---

# Строки документации (docstring)

<!--  -->

```py
def calculate_flow_density(x: list[float], d: list[float]) -> float:
    """
    Calculates density of material flow

    Parameters
    ----------
    x : list[float]
        A list of components mass fractions.
    d : list[float]
        A list of components densities in kg/m^3.

    Returns
    -------
    float
        Flow density [kg/m^3].

    """
    density = 0

    for i in range(len(x)):
        density += x[i] / d[i]
    
    return density ** -1
```

---

<style scoped>
  section {
    justify-content: center;
    font-size: 30px
  }
</style>

<!-- _paginate: skip -->
![bg right opacity:.3](sectiongk.jpeg)

![w:520](logoclr.png)

<br>
<br>

# Благодарю за внимание!

<br>
<br>

Вячеслав Алексеевич Чузлов
к.т.н., доцент ОХИ ИШПР
